<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Trebia: Final</title>
<style>
  :root{
    --bg:#1a1a1c;
    --red:#ef4444; --gold:#f59e0b; --blue:#3b82f6; --text:#e7e7ea;
  }
  *{box-sizing:border-box; user-select:none; -webkit-user-select:none; -webkit-tap-highlight-color:transparent;}

  html,body{
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,sans-serif;
    height:100dvh; width:100%;
    overflow:hidden;
    display:flex; align-items:center; justify-content:center;
    overscroll-behavior:none;
  }

  #game-box{
    position:relative; width:100%; height:100%;
    max-width:800px; background:#2e2e30;
    overflow:hidden;
    box-shadow:0 0 20px rgba(0,0,0,0.5);
    touch-action:none; /* helps keep mobile from scrolling/zooming */
  }

  canvas{width:100%; height:100%; display:block; image-rendering:pixelated;}

  /* FOG */
  #fog-layer{
    position:absolute; inset:0; pointer-events:none; z-index:5;
    background: linear-gradient(to bottom, rgba(200,210,220,0.95) 0%, rgba(200,210,220,0.85) 40%, rgba(200,210,220,0.6) 100%);
    transition: opacity 2s ease-in-out;
  }

  /* HUD */
  .hud-top{
    position:absolute; top:10px; left:0; width:100%; height:40px; z-index:15;
    display:flex; justify-content:center; align-items:center;
    pointer-events:none; font-weight:900; font-size:15px;
    text-shadow:0 1px 3px #000; gap:15px;
  }
  .team-rom{color:var(--red);}
  .team-han{color:#93c5fd;}

  /* CONTROLS */
  .controls-layer{position:absolute; inset:0; z-index:20; pointer-events:none;}

  #stick-zone{
    position:absolute; bottom:20px; left:20px;
    width:140px; height:140px; pointer-events:auto;
    background:rgba(0,0,0,0.1); border-radius:50%;
  }
  .stick-bg{
    width:100%; height:100%; border-radius:50%;
    border:2px solid rgba(255,255,255,0.2); position:relative;
  }
  .stick-nub{
    position:absolute; top:50%; left:50%;
    width:50px; height:50px; margin:-25px 0 0 -25px;
    background:rgba(255,255,255,0.8); border-radius:50%;
    box-shadow:0 2px 5px rgba(0,0,0,0.5);
  }

  .btn-wrapper{
    position:absolute; bottom:30px; right:30px;
    display:flex; flex-direction:column; gap:10px;
    pointer-events:auto; align-items:center;
  }
  #btn-attack{
    width:75px; height:75px;
    background:rgba(245,158,11,0.95);
    border:3px solid #fff; border-radius:50%;
    display:grid; place-items:center;
    box-shadow:0 4px 10px rgba(0,0,0,0.6);
  }
  #btn-attack:active{transform:scale(0.95); background:#d97706;}
  .sword-icon{font-size:32px;}
  .btn-label{
    font-size:11px;
    font-weight:900;
    letter-spacing:1px;
    color:rgba(255,255,255,0.9);
    text-shadow:0 1px 3px rgba(0,0,0,0.9);
    margin-top:-2px;
    pointer-events:none;
  }

  #center-msg{
    position:absolute; top:30%; left:50%; transform:translate(-50%,-50%);
    text-align:center; width:90%; pointer-events:none; z-index:30;
  }
  .big-text{
    font-size:24px; font-weight:900; color:#fff;
    text-shadow:0 2px 8px rgba(0,0,0,1);
    opacity:0; transition:opacity 0.5s;
  }

  #overlay{
    position:absolute; inset:0; background:rgba(0,0,0,0.95); z-index:100;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    padding:20px; text-align:center;
  }
  h1{color:#93c5fd; margin:0 0 10px 0; font-size:32px; letter-spacing:2px;}
  p{color:#ccc; margin-bottom:16px; font-size:15px; max-width:360px; line-height:1.5;}
  .btn-row{display:flex; gap:10px; flex-wrap:wrap; justify-content:center;}
  .btn-start{
    background:var(--red); color:#fff; border:none; padding:14px 22px;
    font-size:16px; font-weight:900; border-radius:8px;
    box-shadow:0 4px 0 #991b1b;
  }
  .btn-muted{
    background:#475569; color:#fff; border:none; padding:14px 22px;
    font-size:16px; font-weight:900; border-radius:8px;
    box-shadow:0 4px 0 #334155;
  }

  /* On desktop, make the mobile controls a bit smaller so they don’t dominate */
  @media (hover:hover) and (pointer:fine){
    #stick-zone{ width:120px; height:120px; bottom:18px; left:18px; opacity:0.9; }
    #btn-attack{ width:68px; height:68px; }
    .btn-label{ font-size:10px; }
  }
</style>
</head>
<body>

<div id="game-box">
  <div id="fog-layer"></div>

  <div id="overlay"></div>

  <div class="hud-top">
    <span class="team-rom">ROMANS: <span id="ui-rome">0</span></span>
    <span class="team-han">CARTHAGE: <span id="ui-han">0</span></span>
  </div>

  <div id="center-msg"><div class="big-text" id="battle-text"></div></div>
  <canvas id="cv"></canvas>

  <div class="controls-layer">
    <div id="stick-zone"><div class="stick-bg"><div class="stick-nub" id="stick"></div></div></div>
    <div class="btn-wrapper">
      <div id="btn-attack" aria-label="Attack" ontouchstart="handleAttack(event)" onmousedown="handleAttack(event)">
        <div class="sword-icon">⚔️</div>
      </div>
      <div class="btn-label">SPACEBAR</div>
    </div>
  </div>
</div>

<script>
// =========================
//  ASSETS & SPRITES
// =========================
const P = {
  metal:'#b7bcc5', black:'#111114',
  roman:'#c53030', you:'#1f9d55', inv:'#7a4a21',
  gold:'#fbbf24', white:'#e7e7ea', elephant: '#555',
  ice: '#a5f3fc', deep: '#172554', reeds: '#22d3ee',
  shadow:'rgba(0,0,0,0.35)'
};
const CANVAS = document.getElementById('cv');
const CTX = CANVAS.getContext('2d');
const BOX = document.getElementById('game-box');
const NEXT_PAGE = "map.html";

// One history block only (no duplicate module)
const HISTORY_HTML = `
  <h2 style="color:#ef4444; margin:0 0 10px 0;">BATTLE OF THE TREBIA (218 BC)</h2>
  <div style="text-align:left; font-size:14px; color:#ccc; line-height:1.6;">
    <p><strong style="color:#fff">FORCES:</strong><br>
    <span style="color:#ef4444">Rome:</span> ~42,000 (Sempronius Longus)<br>
    <span style="color:#93c5fd">Carthage:</span> ~30,000 (Hannibal)</p>

    <p><strong style="color:#fff">CASUALTIES:</strong><br>
    <span style="color:#ef4444">Rome:</span> ~26,000–32,000 killed or captured<br>
    <span style="color:#93c5fd">Carthage:</span> ~5,000 (mostly Celtic allies)</p>

    <p><strong style="color:#fff">SIGNIFICANCE:</strong><br>
    Hannibal’s first major victory. The Romans were baited into crossing the freezing river before breakfast, leaving them cold, hungry, and exhausted. Mago’s hidden force struck their rear.</p>
  </div>
`;

function px(x,y,s,c){CTX.fillStyle=c; CTX.fillRect(x,y,s,s);}

function drawSprite(u, scale){
  const x = u.x * TILE - (u.type==='elephant'?0:4);
  const y = u.y * TILE - 8;
  const s = scale;
  let coat = u.type==='roman'?P.roman:(u.type==='yours'?P.you:P.inv);

  if(u.frozen > 0) coat = '#06b6d4';

  if(u.type === 'elephant'){
    CTX.fillStyle = 'rgba(0,0,0,0.4)';
    CTX.beginPath(); CTX.ellipse(x+8*s, y+10*s, 8*s, 4*s, 0,0,Math.PI*2); CTX.fill();
    CTX.fillStyle = '#666'; CTX.fillRect(x, y-5*s, 16*s, 14*s);
    CTX.fillStyle = '#888'; CTX.fillRect(x-2*s, y-4*s, 4*s, 8*s); CTX.fillRect(x+14*s, y-4*s, 4*s, 8*s);
    CTX.fillStyle = '#fff'; CTX.fillRect(x+4*s, y+6*s, 2*s, 6*s); CTX.fillRect(x+10*s, y+6*s, 2*s, 6*s);
    CTX.fillStyle = '#555'; CTX.fillRect(x+7*s, y+2*s, 2*s, 10*s);
    return;
  }

  CTX.fillStyle=P.shadow; CTX.beginPath(); CTX.ellipse(x+4*s, y+7*s, 4*s, 2*s, 0, 0, Math.PI*2); CTX.fill();
  px(x+1*s, y+6*s, s, P.black); px(x+6*s, y+6*s, s, P.black);
  px(x+2*s, y+5*s, s, P.metal); px(x+5*s, y+5*s, s, P.metal);
  for(let dx=2; dx<=5; dx++) px(x+dx*s, y+3*s, s, coat);
  if(u.type==='roman'){ px(x+3*s,y,s,P.gold); px(x+4*s,y,s,P.gold); }
  else if(u.type==='yours'){ px(x+3*s,y,s,P.white); px(x+4*s,y,s,P.white); }
  else if(u.type==='invader'){ px(x+3*s,y,s,'#444'); px(x+4*s,y,s,'#444'); }
}

function drawRiverTile(x, y, type){
  const s = TILE;
  const X = x*s; const Y = y*s;

  if(type === 1){
    CTX.fillStyle = P.deep;
    CTX.fillRect(X,Y,s,s);
    if((Math.floor(Date.now()/600) + x)%4 === 0){
      CTX.fillStyle = 'rgba(0,0,0,0.3)'; CTX.fillRect(X, Y+s/2, s, 2);
    }
  } else {
    CTX.fillStyle = P.reeds;
    CTX.fillRect(X,Y,s,s);
    px(X+4, Y+4, 2, '#155e75'); px(X+12, Y+10, 2, '#155e75'); px(X+18, Y+2, 2, '#155e75');
  }
}

// =========================
//  CONFIG
// =========================
const TILE = 24;
const GRID_W = 40;
const GRID_H = 60;
let SCALE = 2;

const PACE = {
  move: 15,
  frozenMove: 40,
  elephantSpeed: 25,
  panicSpeed: 10
};

// =========================
//  STATE
// =========================
let gameActive = false;
let cam = {x:0, y:0};
let grid = [];
let terrain = [];
let units = [];
let particles = [];
let snow = [];
let floats = [];
let player = null;

let battlePhase = 0; // 0=Cross, 1=Reveal, 2=Rout
let phaseTimer = 0;

let input = {dx:0, dy:0};

// Keyboard state (desktop)
const keyState = {up:false, down:false, left:false, right:false};
function recomputeKeyInput(){
  // Resolve axis with simple priority: if both pressed, cancel that axis.
  const x = (keyState.left? -1:0) + (keyState.right? 1:0);
  const y = (keyState.up? -1:0) + (keyState.down? 1:0);

  // If stick is active, it already sets input. Only apply keyboard when stick inactive.
  if(stick.active) return;

  input.dx = (x===0 ? 0 : (x>0 ? 1 : -1));
  input.dy = (y===0 ? 0 : (y>0 ? 1 : -1));

  // Optional: avoid diagonal movement (keep your original “one axis” feel)
  if(input.dx && input.dy){
    // pick the most recently pressed axis by favoring horizontal when both
    // (simple, consistent)
    input.dy = 0;
  }
}

// Virtual stick
let stick = {active:false, startX:0, startY:0, curX:0, curY:0};

function buildIntro(){
  const overlay = document.getElementById('overlay');
  overlay.style.display = 'flex';
  overlay.innerHTML = `
    <h1>TREBIA</h1>
    <p><b>Winter, 218 BC.</b></p>
    <p>Cross the freezing river to ambush Hannibal.</p>
    <p><b>Warning:</b> The river is freezing. If you get wet, you will be slow for the entire battle.</p>
    <p style="margin-top:6px; color:#bbb; font-size:13px;">
      <b>Desktop:</b> Arrow keys / WASD to move, <b>Space</b> to slash.
    </p>
    <div class="btn-row">
      <button class="btn-start" id="btn-start">CROSS THE RIVER</button>
      <button class="btn-muted" id="btn-history">HISTORY</button>
    </div>
  `;
  document.getElementById('btn-start').onclick = startGame;
  document.getElementById('btn-history').onclick = () => showHistoryOverlay();
}
function showHistoryOverlay(){
  const overlay = document.getElementById('overlay');
  overlay.style.display = 'flex';
  overlay.innerHTML = `
    <h1>HISTORY</h1>
    ${HISTORY_HTML}
    <div class="btn-row" style="margin-top:18px;">
      <button class="btn-muted" id="btn-back">BACK</button>
    </div>
  `;
  document.getElementById('btn-back').onclick = buildIntro;
}

buildIntro();

function startGame(){
  document.getElementById('overlay').style.display = 'none';
  if(gameActive) return;
  gameActive = true;
  resize();
  setupMap();
  requestAnimationFrame(loop);
}

function setupMap(){
  units = []; grid = []; particles = []; floats = []; snow = [];
  grid = Array(GRID_H).fill(0).map(()=>Array(GRID_W).fill(null));
  terrain = Array(GRID_H).fill(0).map(()=>Array(GRID_W).fill(0));

  battlePhase = 0; phaseTimer = 0;

  const CX = Math.floor(GRID_W/2);

  // River: 4 tiles wide (y=30..33)
  for(let y=30; y<34; y++){
    for(let x=0; x<GRID_W; x++){
      let band = Math.floor(x / 3);
      terrain[y][x] = (band % 2 === 0) ? 2 : 1; // Reeds vs Deep
    }
  }

  player = spawnUnit(CX, 50, 'yours');
  player.attackCd = 0;

  cam.x = player.x*TILE; cam.y = player.y*TILE;

  for(let x=0; x<GRID_W; x++){
    for(let y=48; y<55; y++){
      if(Math.random()>0.2) spawnUnit(x,y,'roman');
    }
  }

  for(let i=0; i<50; i++) snow.push({x:Math.random()*GRID_W*TILE, y:Math.random()*GRID_H*TILE, s:Math.random()*2+1});

  showMsg("FOLLOW THE REEDS!", "#fff");
  document.getElementById('fog-layer').style.opacity = 1;
}

function spawnUnit(gx, gy, type){
  if(gx<0||gx>=GRID_W||gy<0||gy>=GRID_H||grid[gy][gx]) return null;
  let hp = type==='elephant' ? 80 : (type==='yours'?50:6);
  let u = {
    id:Math.random(), x:gx, y:gy, type, hp, maxHp:hp,
    cooldown:Math.random()*20, frozen:0, state:'normal'
  };
  units.push(u);
  grid[gy][gx] = u;
  return u;
}

// =========================
//  LOGIC
// =========================
function loop(){
  if(!gameActive) return;
  update();
  draw();
  requestAnimationFrame(loop);
}

function update(){
  phaseTimer++;

  if(player && player.attackCd > 0) player.attackCd--;

  // Ambush trigger
  if(battlePhase === 0 && player.y < 28){
    battlePhase = 1;
    document.getElementById('fog-layer').style.opacity = 0;
    showMsg("THE FOG LIFTS...", "#fff");

    setTimeout(()=>{
      showMsg("IT'S MAGO! BEHIND US!", "#ef4444");
      battlePhase = 2;

      spawnUnit(15, 12, 'elephant');
      spawnUnit(20, 10, 'elephant');
      spawnUnit(25, 12, 'elephant');

      for(let x=0; x<40; x+=3){
        for(let y=5; y<15; y+=3){
          if(Math.random()>0.5) spawnUnit(x, y, 'invader');
        }
      }

      for(let x=0; x<40; x+=4){
        spawnUnit(x, 50, 'invader');
        spawnUnit(x+1, 51, 'invader');
      }

    }, 2000);
  }

  // Camera
  let tx = player.x*TILE;
  let ty = player.y*TILE;
  cam.x += (tx - cam.x)*0.1;
  cam.y += (ty - cam.y)*0.1;

  units.sort((a,b)=>a.y-b.y);

  for(let u of units){
    if(u.hp<=0) continue;

    // Terrain effects
    let t = terrain[u.y][u.x];
    if(t === 1){
      if(frameStep(30)){
        u.hp -= 3;
        spawnFloat("Drowning", u.x, u.y, "#3b82f6");
      }
      u.frozen = 1350;
    } else if (t === 2){
      if(u.frozen <= 0) u.frozen = 1350;
    }
    if(u.frozen > 0) u.frozen--;

    if(u.type==='yours'){
      if(u.cooldown>0) u.cooldown--;
      if(u.cooldown<=0 && (input.dx||input.dy)){
        tryMove(u, input.dx, input.dy);
        u.cooldown = (u.frozen>0) ? PACE.frozenMove : PACE.move;
      }
    } else {
      handleAI(u);
    }
  }

  units = units.filter(u=>u.hp>0);
  updateFX();

  if(player.hp<=0) gameOver("Died in the Trebia.");
  document.getElementById('ui-rome').innerText = units.filter(u=>u.type==='roman').length;
  document.getElementById('ui-han').innerText  = units.filter(u=>u.type==='invader'||u.type==='elephant').length;
}

function handleAI(u){
  if(u.cooldown>0){ u.cooldown--; return; }

  let speed = PACE.move;
  let md = {x:0, y:0};

  if(u.type === 'elephant'){
    speed = PACE.elephantSpeed;
    let target = findNearestEnemy(u);
    if(target){
      md = getStep(u, target);
      let tx = u.x + md.x; let ty = u.y + md.y;
      if(grid[ty] && grid[ty][tx] && grid[ty][tx].type !== 'invader' && grid[ty][tx].type !== 'elephant'){
        let victim = grid[ty][tx];
        victim.hp -= 20;
        spawnBlood(victim.x, victim.y);
        spawnFloat("CRUSH", victim.x, victim.y, "#f00");
        let pushY = victim.y + 1;
        if(pushY < GRID_H && !grid[pushY][victim.x]){
           grid[victim.y][victim.x]=null; victim.y=pushY; grid[victim.y][victim.x]=victim;
        }
      }
    }
  }
  else if(u.type === 'roman'){
    if(battlePhase === 2){
      speed = PACE.panicSpeed;
      if(Math.random() > 0.2) md = {x: (Math.random()>0.5?1:-1), y: 1};
      else md = {x: (Math.random()-0.5)*2 > 0 ? 1 : -1, y: (Math.random()-0.5)*2 > 0 ? 1 : -1};
      spawnFloat("!", u.x, u.y, "#fff");
    } else {
      let nextY = u.y - 1;
      let nextX = u.x;
      if(isSafe(nextX, nextY)){
        md = {x:0, y:-1};
      } else if(isSafe(nextX-1, nextY) || isSafe(nextX-1, u.y)){
        md = {x:-1, y:0};
      } else if(isSafe(nextX+1, nextY) || isSafe(nextX+1, u.y)){
        md = {x:1, y:0};
      } else {
        md = {x:0, y:-1};
      }
    }
  }
  else if(u.type === 'invader'){
     let target = findNearestEnemy(u);
     if(target){
       if(dist(u,target)<=1.5){
         attack(u, target);
         u.cooldown = 45;
         return;
       }
       md = getStep(u, target);
     }
  }

  if(md.x||md.y) tryMove(u, md.x, md.y);
  u.cooldown = (u.frozen>0) ? speed * 2.5 : speed;
  u.cooldown += Math.random()*10;
}

function isSafe(x, y){
  if(x<0 || x>=GRID_W || y<0 || y>=GRID_H) return false;
  return terrain[y][x] !== 1;
}

function tryMove(u, dx, dy){
  let tx=u.x+dx, ty=u.y+dy;
  if(tx<0||tx>=GRID_W||ty<0||ty>=GRID_H || grid[ty][tx]) return;
  grid[u.y][u.x]=null; u.x=tx; u.y=ty; grid[ty][tx]=u;
}

function attack(atk, def){
  let dmg = 1;
  if(def.type === 'elephant'){
    if(atk.y < def.y){
       dmg = 80;
       spawnFloat("BACKSTAB!", def.x, def.y, P.gold);
    } else {
       dmg = 0;
       spawnFloat("TINK", def.x, def.y, "#ccc");
    }
  }
  def.hp -= dmg;
  spawnBlood(def.x, def.y);
  if(dmg > 0) spawnFloat("-"+dmg, def.x, def.y, "#ef4444");

  if(def.hp<=0){
    grid[def.y][def.x]=null;
    spawnFloat("KILL", def.x, def.y, P.gold);
  }
}

// =========================
//  VISUALS & FX
// =========================
function draw(){
  CTX.fillStyle=P.black;
  CTX.fillRect(0,0,CANVAS.width,CANVAS.height);

  CTX.save();
  let cx = CANVAS.width/2 - cam.x;
  let cy = CANVAS.height/2 - cam.y;
  CTX.translate(Math.round(cx), Math.round(cy));

  CTX.fillStyle='#2e2e30';
  CTX.fillRect(0,0,GRID_W*TILE, GRID_H*TILE);

  CTX.fillStyle='#555';
  for(let i=0; i<100; i++) CTX.fillRect((i*47)% (GRID_W*TILE), (i*31)% (GRID_H*TILE), 2, 2);

  for(let y=0; y<GRID_H; y++){
    for(let x=0; x<GRID_W; x++){
      if(terrain[y][x] > 0) drawRiverTile(x, y, terrain[y][x]);
    }
  }

  for(let u of units) drawSprite(u, SCALE);
  for(let p of particles){ CTX.fillStyle=p.color; CTX.fillRect(p.x, p.y, SCALE, SCALE); }

  CTX.font="bold 12px monospace"; CTX.textAlign="center";
  for(let f of floats){ CTX.fillStyle=f.color; CTX.globalAlpha=f.life; CTX.fillText(f.text, f.x+TILE/2, f.y); }
  CTX.globalAlpha=1;

  CTX.fillStyle = '#fff';
  for(let s of snow){
    CTX.fillRect(s.x, s.y, s.s, s.s);
    s.y += 1; s.x += Math.sin(Date.now()/1000);
    if(s.y > GRID_H*TILE) s.y = 0;
  }
  CTX.restore();
}

// =========================
//  UTILS & INPUT
// =========================
let frameC=0; function frameStep(n){ return (frameC++%n)===0; }
function dist(a,b){ return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }
function getStep(u,t){
  let dx=t.x-u.x, dy=t.y-u.y;
  if(Math.abs(dx)>Math.abs(dy)) return {x:Math.sign(dx), y:0};
  return {x:0, y:Math.sign(dy)};
}
function findNearestEnemy(u){
  let target=null, minDist=99;
  for(let o of units){
    if(Math.abs(o.x-u.x)>10 || Math.abs(o.y-u.y)>10) continue;
    let isEnemy = (u.type==='invader'||u.type==='elephant')
      ? (o.type==='roman'||o.type==='yours')
      : (o.type==='invader'||o.type==='elephant');
    if(isEnemy){
      let d=dist(u,o);
      if(d<minDist){minDist=d; target=o;}
    }
  }
  return target;
}
function spawnBlood(gx, gy){
  for(let i=0;i<3;i++) particles.push({x:gx*TILE+TILE/2, y:gy*TILE+TILE/2, vx:(Math.random()-.5)*3, vy:(Math.random()-.5)*3, life:1, color:'#900'});
}
function spawnFloat(txt,gx,gy,col){ floats.push({x:gx*TILE, y:gy*TILE, text:txt, life:1, color:col}); }
function updateFX(){
  particles.forEach(p=>{p.x+=p.vx; p.y+=p.vy; p.life-=0.05});
  particles=particles.filter(p=>p.life>0);
  floats.forEach(f=>{f.y-=0.3; f.life-=0.02});
  floats=floats.filter(f=>f.life>0);
}
function showMsg(txt, col){
  const el=document.getElementById('battle-text');
  el.innerText=txt; el.style.color=col; el.style.opacity=1;
  setTimeout(()=>el.style.opacity=0, 2500);
}
function gameOver(reason){
  gameActive = false;

  const overlay = document.getElementById('overlay');
  overlay.style.display = 'flex';
  overlay.innerHTML = `
    <h1>DEFEAT</h1>
    <p><b>${reason}</b></p>
    <p style="margin-bottom:10px;">The battle is over.</p>
    ${HISTORY_HTML}
    <div class="btn-row" style="margin-top:18px;">
      <button class="btn-start" id="btn-map">RETURN TO MAP</button>
      <button class="btn-muted" id="btn-restart">RESTART</button>
    </div>
  `;

  document.getElementById('btn-map').onclick = () => { window.location.href = NEXT_PAGE; };
  document.getElementById('btn-restart').onclick = () => { location.reload(); };
}

// ----- Virtual stick input (mobile) -----
const stickZone=document.getElementById('stick-zone');
const stickEl=document.getElementById('stick');

stickZone.addEventListener('touchstart',e=>{
  stick.active=true;
  stick.startX=e.touches[0].clientX; stick.startY=e.touches[0].clientY;
  stick.curX=stick.startX; stick.curY=stick.startY;
}, {passive:false});

stickZone.addEventListener('touchmove',e=>{
  if(!stick.active) return;
  e.preventDefault();
  stick.curX=e.touches[0].clientX; stick.curY=e.touches[0].clientY;
  updateStick();
}, {passive:false});

const endStick=()=>{
  stick.active=false;
  stickEl.style.transform='translate(0,0)';
  input.dx=0; input.dy=0;
  // if keyboard is held, restore it
  recomputeKeyInput();
};
stickZone.addEventListener('touchend', endStick);
stickZone.addEventListener('touchcancel', endStick);

function updateStick(){
  let dx=stick.curX-stick.startX, dy=stick.curY-stick.startY;
  let d=Math.sqrt(dx*dx+dy*dy);
  if(d>40){ dx=(dx/d)*40; dy=(dy/d)*40; }
  stickEl.style.transform=`translate(${dx}px, ${dy}px)`;

  input.dx=0; input.dy=0;
  if(d>10){
    if(Math.abs(dx)>Math.abs(dy)) input.dx=Math.sign(dx);
    else input.dy=Math.sign(dy);
  }
}

// ----- Attack (button + spacebar) -----
window.handleAttack = function(e){
  if(e){ e.stopPropagation(); e.preventDefault(); }
  if(!gameActive||!player||player.hp<=0) return;
  if(player.attackCd && player.attackCd>0) return;

  const dirs=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  for(let d of dirs){
    let tx=player.x+d[0], ty=player.y+d[1];
    if(grid[ty]&&grid[ty][tx]) attack(player, grid[ty][tx]);
  }
  spawnFloat("SWING", player.x, player.y, "#fff");
  player.attackCd = 18; // small throttle so holding space doesn’t melt everything
};

// ----- Keyboard controls (desktop) -----
function keyToDirDown(k){
  if(k === 'ArrowUp' || k === 'w' || k === 'W') keyState.up = true;
  if(k === 'ArrowDown' || k === 's' || k === 'S') keyState.down = true;
  if(k === 'ArrowLeft' || k === 'a' || k === 'A') keyState.left = true;
  if(k === 'ArrowRight' || k === 'd' || k === 'D') keyState.right = true;
}
function keyToDirUp(k){
  if(k === 'ArrowUp' || k === 'w' || k === 'W') keyState.up = false;
  if(k === 'ArrowDown' || k === 's' || k === 'S') keyState.down = false;
  if(k === 'ArrowLeft' || k === 'a' || k === 'A') keyState.left = false;
  if(k === 'ArrowRight' || k === 'd' || k === 'D') keyState.right = false;
}

window.addEventListener('keydown', (e)=>{
  // prevent scrolling + button click activation
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();

  if(e.key === ' ' || e.code === 'Space'){
    handleAttack(e);
    return;
  }

  keyToDirDown(e.key);
  recomputeKeyInput();
}, {passive:false});

window.addEventListener('keyup', (e)=>{
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  keyToDirUp(e.key);
  recomputeKeyInput();
}, {passive:false});

// Keep focus on the page so keys work after tapping/clicking
BOX.addEventListener('mousedown', ()=>{ BOX.focus?.(); });
BOX.addEventListener('touchstart', ()=>{ BOX.focus?.(); }, {passive:true});

// Resize
function resize(){
  CANVAS.width=BOX.clientWidth;
  CANVAS.height=BOX.clientHeight;
  CTX.imageSmoothingEnabled=false;
}
window.addEventListener('resize', resize);
</script>

</body>
</html>
