<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Cannae: Chromebook Edition</title>
<style>
  :root{
    --bg:#0f172a; --panel:#1e293b; --border:#334155; --text:#f1f5f9;
    --red:#ef4444; --gold:#f59e0b; --blue:#3b82f6; --green:#22c55e;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family: 'Segoe UI', system-ui, sans-serif;
    height:100vh; overflow:hidden;
    display:flex; align-items:center; justify-content:center;
    touch-action:none;
  }

  /* LAYOUT */
  #app-container{
    display:flex; width:100vw; height:100vh;
    background:#000;
  }

  /* LEFT: BATTLEFIELD */
  #game-stage{
    flex:1; position:relative; background:#2d332d; overflow:hidden;
    border-right:4px solid var(--border);
    cursor:crosshair;
    touch-action:none;
  }
  canvas{display:block; width:100%; height:100%; image-rendering:pixelated;}

  /* TEXT OVERLAYS */
  #center-msg{
    position:absolute; top:20%; left:50%; transform:translate(-50%,-50%);
    text-align:center; width:100%; pointer-events:none; z-index:40;
  }
  .big-text{
    font-size:36px; font-weight:900; color:#fff; letter-spacing:2px;
    text-shadow:0 4px 12px rgba(0,0,0,1);
    opacity:0; transition:opacity 0.5s;
  }

  /* START/END OVERLAY */
  #overlay{
    position:absolute; inset:0; background:rgba(15,23,42,0.96); z-index:50;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    text-align:center;
  }
  .intro-box{
    max-width:600px; padding:40px; border:2px solid var(--border);
    background:var(--panel); border-radius:12px;
    box-shadow:0 20px 50px rgba(0,0,0,0.8);
  }
  h1{color:var(--gold); margin:0 0 15px 0; font-size:32px; letter-spacing:2px; text-transform:uppercase;}
  p{color:#cbd5e1; margin-bottom:15px; font-size:16px; line-height:1.6;}
  .highlight{color:var(--red); font-weight:bold;}
  .btn-start{
    background:var(--red); color:#fff; border:none; padding:16px 40px;
    font-size:18px; font-weight:900; border-radius:6px; cursor:pointer;
    transition:transform 0.1s; box-shadow:0 4px 0 #991b1b; margin-top:10px;
  }
  .btn-start:hover{transform:scale(1.03);}
  .btn-muted{
    background:#475569; box-shadow:0 4px 0 #334155;
  }
  .btn-gold{
    background:var(--gold); box-shadow:0 4px 0 #92400e;
  }

  /* RIGHT: SIDEBAR */
  #sidebar{
    width:340px; background:var(--panel);
    display:flex; flex-direction:column;
    z-index:20; border-left:1px solid var(--border);
  }
  .sb-header{
    padding:20px; background:rgba(0,0,0,0.2); border-bottom:1px solid var(--border);
  }
  .game-title{font-weight:900; font-size:14px; letter-spacing:1px; color:var(--gold);}

  .stats-container{
    padding:20px; display:grid; gap:12px;
  }
  .stat-row{
    display:flex; justify-content:space-between; align-items:center;
    padding:12px; background:rgba(255,255,255,0.05); border-radius:6px;
    border:1px solid rgba(255,255,255,0.1);
  }
  .stat-label{font-size:11px; text-transform:uppercase; font-weight:bold; color:#94a3b8;}
  .stat-val{font-size:18px; font-weight:900;}
  .val-rom{color:var(--red);}
  .val-han{color:var(--blue);}

  .info-box{
    padding:20px; flex:1; border-top:1px solid var(--border);
    background:rgba(0,0,0,0.2); overflow-y:auto;
  }
  .log-line{
    font-family:monospace; font-size:11px; margin-bottom:6px; padding-bottom:6px;
    border-bottom:1px solid rgba(255,255,255,0.05); color:#cbd5e1;
  }
  .log-line.event{color:var(--gold); font-weight:bold;}

  .controls-hint{
    padding:15px; background:#0f172a; border-top:1px solid var(--border);
    font-size:11px; color:#64748b; text-align:center;
  }
  kbd{
    background:#333; padding:2px 6px; border-radius:3px; border:1px solid #555;
    color:#fff; font-family:monospace; font-weight:bold; font-size:12px;
  }
</style>
</head>
<body>

<div id="app-container">

  <div id="game-stage">
    <div id="center-msg"><div class="big-text" id="battle-text"></div></div>
    <canvas id="cv"></canvas>

    <div id="overlay">
      <div class="intro-box" id="intro-box"></div>
    </div>
  </div>

  <div id="sidebar">
    <div class="sb-header">
      <div class="game-title">TACTICAL LOG</div>
    </div>

    <div class="stats-container">
      <div class="stat-row">
        <span class="stat-label">Roman Legions</span>
        <span class="stat-val val-rom" id="ui-rome">0</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Carthaginians</span>
        <span class="stat-val val-han" id="ui-han">0</span>
      </div>
    </div>

    <div class="info-box" id="log-box">
      <div class="log-line">Battle commencing...</div>
    </div>

    <div class="controls-hint">
      Desktop: <kbd>WASD</kbd>/<kbd>ARROWS</kbd> Move &nbsp;&bull;&nbsp; <kbd>SPACE</kbd> Attack<br>
      Mobile: Drag to move &nbsp;&bull;&nbsp; Double-tap to attack
    </div>
  </div>

</div>

<script>
// ===================================================
//  ROUTING / END FLOW
// ===================================================
const NEXT_PAGE = "map.html";
function goToMap(){ window.location.href = NEXT_PAGE; }

// ===================================================
//  OVERLAY CONTENT (INTRO / HISTORY / END)
// ===================================================
const INTRO_HTML = `
  <h1>BATTLE OF CANNAE</h1>
  <p><b>216 BC.</b> Hannibal's greatest victory.</p>
  <p>You are a Roman Centurion caught in the center. The line will bend, then break.</p>
  <p class="highlight">SURVIVE THE CRUSH.</p>
  <button class="btn-start" id="btn-start">FORM RANKS</button>
`;

const HISTORY_HTML = `
  <h1 style="color:var(--red)">CANNAE (216 BC)</h1>
  <div style="text-align:left; font-size:14px; color:#ccc; line-height:1.6;">
    <p><strong style="color:#fff">FORCES:</strong><br>
      <span style="color:#ef4444">Rome:</span> ~86,000 (Varro &amp; Paullus)<br>
      <span style="color:#60a5fa">Carthage:</span> ~50,000 (Hannibal)
    </p>
    <p><strong style="color:#fff">CASUALTIES:</strong><br>
      <span style="color:#ef4444">Rome:</span> ~50,000â€“75,000 killed<br>
      <span style="color:#60a5fa">Carthage:</span> ~6,000
    </p>
    <p><strong style="color:#fff">SIGNIFICANCE:</strong><br>
      Hannibal allowed his weak center to retreat, drawing the Romans in.
      His infantry on the wings then turned inward, and cavalry hit the rear.
      Packed so tight, the Romans could barely fight back.
    </p>
  </div>
`;

function renderIntro(){
  const box = document.getElementById('intro-box');
  box.innerHTML = INTRO_HTML;

  const histBtn = document.createElement('button');
  histBtn.className = "btn-start btn-muted";
  histBtn.textContent = "HISTORY";
  histBtn.style.marginTop = "10px";
  histBtn.onclick = ()=> renderHistory('intro');
  box.appendChild(histBtn);

  document.getElementById('btn-start').onclick = startGame;
}

function renderHistory(backTo){
  const box = document.getElementById('intro-box');
  box.innerHTML = `
    ${HISTORY_HTML}
    <button class="btn-start btn-muted" id="btn-back" style="margin-top:18px;">BACK</button>
  `;
  document.getElementById('btn-back').onclick = ()=> {
    if(backTo === 'intro') renderIntro();
  };
}

function finishRun(title, msg){
  gameActive=false;
  document.getElementById('overlay').style.display='flex';
  const box = document.getElementById('intro-box');

  box.innerHTML = `
    <h1 style="color:var(--red)">${title}</h1>
    <p><b>${msg}</b></p>
    ${HISTORY_HTML}
    <button class="btn-start btn-gold" id="btn-map" style="margin-top:18px;">RETURN TO MAP</button>
    <button class="btn-start btn-muted" id="btn-replay" style="margin-top:10px;">REPLAY</button>
  `;

  document.getElementById('btn-map').onclick = goToMap;
  document.getElementById('btn-replay').onclick = ()=> { renderIntro(); };

  // Auto return (keeps pacing, still readable)
  setTimeout(goToMap, 2200);
}

// ===================================================
//  ASSETS
// ===================================================
const P = {
  metal:'#b7bcc5', black:'#111114',
  roman:'#c53030', you:'#1f9d55', inv:'#7a4a21',
  gold:'#fbbf24', white:'#e7e7ea',
  mane:'#2b1a10', hoof:'#0b0b0c',
  shadow:'rgba(0,0,0,0.35)'
};

const CANVAS = document.getElementById('cv');
const CTX = CANVAS.getContext('2d', {alpha:false});
const STAGE = document.getElementById('game-stage');

// ===================================================
//  CONFIG
// ===================================================
const TILE = 24;
const GRID_W = 40;
const GRID_H = 60;
let SCALE = 3; // Desktop scale (we'll auto-tune on small screens)

const PACE = {
  playerMove: 16,
  romanMove: 34,
  invaderMove: 40,
  cavalryMove: 18,
  aiThinkJitter: 26,
  combatDelay: 56
};

const PHASE = {
  bendAt: 280,
  encircleAt: 1050,
  reinfAt: 1450
};

const PLAYER_ATTACK = { cooldownFrames: 18, maxHits: 2 };
const PRESSURE = {
  blockDiagonalWhenEngaged: true,
  shoveChance: 0.25
};
const KNOT = {
  startR: 12, endR: 4, shrinkEvery: 160
};

// ===================================================
//  STATE
// ===================================================
let gameActive = false;
let cam = {x:0, y:0};
let grid = [];
let units = [];
let particles = [];
let floats = [];
let player = null;

let battlePhase = 0;
let phaseTimer = 0;
let hasReinforced = false;
let frontY = 0;
let doom = { x:0, y:0, r:KNOT.startR };

// Input
const keys = {w:false, a:false, s:false, d:false, up:false, down:false, left:false, right:false};
let atkCD = 0;

// Touch movement (mobile)
let touchMove = {active:false, startX:0, startY:0, dx:0, dy:0, lastTap:0};

let DPR=1, VIEW_W=0, VIEW_H=0;

function resize(){
  const rect = STAGE.getBoundingClientRect();
  VIEW_W = Math.max(1, Math.floor(rect.width));
  VIEW_H = Math.max(1, Math.floor(rect.height));
  DPR = Math.min(3, window.devicePixelRatio || 1);

  CANVAS.width = Math.floor(VIEW_W * DPR);
  CANVAS.height = Math.floor(VIEW_H * DPR);
  CTX.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
  CTX.imageSmoothingEnabled = false;

  // Auto scale down on small screens so units don't become huge
  SCALE = (VIEW_W < 700) ? 2 : 3;
}
window.addEventListener('resize', resize, {passive:true});
window.addEventListener('orientationchange', resize, {passive:true});

function startGame(){
  document.getElementById('overlay').style.display = 'none';
  if(gameActive) return;
  gameActive = true;
  resize();
  setupMap();
  requestAnimationFrame(loop);
}

function setupMap(){
  units = []; particles = []; floats = [];
  grid = Array(GRID_H).fill(0).map(()=>Array(GRID_W).fill(null));
  battlePhase = 0; phaseTimer = 0; hasReinforced = false;

  const CX = Math.floor(GRID_W/2);
  const CY = Math.floor(GRID_H/2);
  frontY = CY - 6;

  player = spawnUnit(CX, CY+2, 'yours');
  cam.x = player.x*TILE; cam.y = player.y*TILE;
  doom.x = player.x; doom.y = player.y; doom.r = KNOT.startR;

  // ROMANS
  for(let y=CY; y<CY+10; y++){
    for(let x=CX-7; x<CX+7; x++){
      if(Math.random()>0.1 && !grid[y][x]){
        const u = spawnUnit(x, y, 'roman');
        if(u) u.role = (y >= CY+5) ? 'reserve' : 'front';
      }
    }
  }

  // CARTHAGE (Crescent Formation)
  for(let x=CX-12; x<CX+12; x++){
    const dist = Math.abs(x-CX);
    const curve = Math.floor((dist*dist)/16);
    const frontRow = (CY-5) - curve;
    for(let r=0; r<2; r++){
      const uy = frontRow - r;
      if(uy>2 && uy<GRID_H && x>2 && x<GRID_W-2 && !grid[uy][x]){
        if(Math.random() < 0.75) spawnUnit(x, uy, 'invader');
      }
    }
  }

  // Center Thickening
  let added = 0;
  const centerXs = [];
  for(let d=0; d<=12; d++){
    if(CX-d > 2) centerXs.push(CX-d);
    if(d!==0 && CX+d < GRID_W-3) centerXs.push(CX+d);
  }
  for(const x of centerXs){
    if(added >= 20) break;
    const dist = Math.abs(x-CX);
    const curve = Math.floor((dist*dist)/16);
    const frontRow = (CY-5) - curve;
    for(const uy of [frontRow, frontRow-1]){
      if(added >= 20) break;
      if(uy>2 && uy<GRID_H-2 && !grid[uy][x]){
        spawnUnit(x, uy, 'invader');
        added++;
      }
    }
  }

  showMsg("ADVANCE!", "#fff");
  updateUI();
}

function spawnUnit(gx, gy, type){
  if(gx<0||gx>=GRID_W||gy<0||gy>=GRID_H || grid[gy][gx]) return null;
  let hp, maxHp, moveSpeed;
  if(type === 'yours'){ hp=80; maxHp=100; moveSpeed=PACE.playerMove; }
  else if(type === 'roman'){ hp=8; maxHp=8; moveSpeed=PACE.romanMove; }
  else if(type === 'cavalry'){ hp=15; maxHp=15; moveSpeed=PACE.cavalryMove; }
  else { hp=12; maxHp=12; moveSpeed=PACE.invaderMove; }

  const u = {
    id: Math.random(), x: gx, y: gy, type, hp, maxHp,
    cooldown: Math.random()*60, moveSpeed, role: null
  };
  units.push(u);
  grid[gy][gx] = u;
  return u;
}

// =========================
//  LOOP
// =========================
function loop(){
  if(!gameActive) return;

  let dx=0, dy=0;

  // keyboard intent
  if(keys.left || keys.a) dx=-1;
  if(keys.right || keys.d) dx=1;
  if(keys.up || keys.w) dy=-1;
  if(keys.down || keys.s) dy=1;

  // touch intent overrides keyboard when active
  if(touchMove.active){
    dx = touchMove.dx;
    dy = touchMove.dy;
  }

  update(dx, dy);
  draw();
  requestAnimationFrame(loop);
}

function update(pDx, pDy){
  phaseTimer++;
  if(atkCD>0) atkCD--;

  const CX = Math.floor(GRID_W/2);
  const CY = Math.floor(GRID_H/2);

  // Phases
  if(battlePhase === 0 && phaseTimer > PHASE.bendAt){
    battlePhase = 1;
    showMsg("THE LINE BENDS...", P.gold);
    log("The center gives ground. A trap?", "event");
  }
  if(battlePhase === 1 && phaseTimer > PHASE.encircleAt){
    battlePhase = 2;
    showMsg("ENCIRCLED.", P.roman);
    log("Flanks collapsed. We are surrounded.", "event");
    for(let y=CY-12; y<CY+12; y++){
      let a = spawnUnit(2, y, 'invader'); if(a) a.role='sealer';
      let b = spawnUnit(GRID_W-3, y, 'invader'); if(b) b.role='sealer';
    }
  }
  if(battlePhase === 2 && phaseTimer > PHASE.reinfAt && !hasReinforced){
    hasReinforced = true;
    showMsg("NUMIDIAN CAVALRY!", "#fbbf24");
    log("Cavalry hits the rear. Total encirclement.", "event");
    for(let x=CX-8; x<=CX+8; x+=2){
      let c1 = spawnUnit(x, player.y+10, 'cavalry'); if(c1) c1.role='rearSealer';
    }
  }

  // Camera
  if(player && player.hp>0){
    let tx = player.x*TILE + TILE/2;
    let ty = player.y*TILE + TILE/2;
    cam.x += (tx-cam.x)*0.1;
    cam.y += (ty-cam.y)*0.1;
  }

  // Crush zone
  if(battlePhase >= 2){
    const t = Math.max(0, phaseTimer - PHASE.encircleAt);
    const steps = Math.floor(t / KNOT.shrinkEvery);
    doom.r = Math.max(KNOT.endR, KNOT.startR - steps);
  } else {
    doom.r = KNOT.startR;
  }

  // Units
  units.sort((a,b)=>a.y-b.y);
  for(const u of units){
    if(u.hp<=0) continue;
    if(u.type==='yours'){
      if(u.cooldown>0) u.cooldown--;
      if(u.cooldown<=0 && (pDx || pDy)){
        tryMove(u, pDx, pDy);
        u.cooldown = u.moveSpeed;
        if(isEngaged(u)) u.cooldown *= 2.0;
      }
    } else {
      handleAI(u, CX, CY);
    }
  }

  units = units.filter(u=>u.hp>0);
  updateFX();
  updateUI();

  if(player && player.hp<=0){
    finishRun("SLAUGHTERED", "Crushed in the press.");
  }
}

// =========================
//  AI
// =========================
function handleAI(u, CX, CY){
  if(u.cooldown>0){ u.cooldown--; return; }

  let target=null, minDist=99;
  for(const o of units){
    if(Math.abs(o.x-u.x)>3 || Math.abs(o.y-u.y)>3) continue;
    const isEnemy = (!isInvaderType(u.type) && isInvaderType(o.type)) ||
                    ( isInvaderType(u.type) && !isInvaderType(o.type) );
    if(isEnemy){
      const d = dist(u,o);
      if(d<minDist){ minDist=d; target=o; }
    }
  }

  if(target && minDist<=1.5){
    attack(u, target);
    u.cooldown = PACE.combatDelay + Math.random()*20;
    return;
  }

  let md = {x:0, y:0};
  if(isInvaderType(u.type)){
    if(battlePhase >= 2){
      const dx = doom.x - u.x;
      const dy = doom.y - u.y;
      const d = Math.hypot(dx, dy);

      if(d > doom.r + 1){
        md = (Math.abs(dx) > Math.abs(dy)) ? {x:Math.sign(dx), y:0} : {x:0, y:Math.sign(dy)};
      } else {
        md = (Math.random()<0.5) ? {x:(dy>0?1:-1), y:0} : {x:0, y:(dx>0?-1:1)};
      }
    } else {
      if(u.y < frontY + 6 && Math.random() < 0.65) md = {x:0, y:1};
      else if(target) md = getStep(u, target);
    }
  }

  if(u.type==='roman'){
    if(target) md = getStep(u, target);
    else md = {x:0, y:-1};
  }

  if(md.x || md.y) tryMove(u, md.x, md.y);
  u.cooldown = u.moveSpeed + Math.random()*PACE.aiThinkJitter;
}

// =========================
//  MOVEMENT & PHYSICS
// =========================
function isInvaderType(t){ return (t==='invader' || t==='cavalry'); }

function countAdjacentInvaders(gx, gy){
  let c=0;
  for(let dy=-1; dy<=1; dy++){
    for(let dx=-1; dx<=1; dx++){
      if(dx===0 && dy===0) continue;
      const x=gx+dx, y=gy+dy;
      if(grid[y] && grid[y][x] && isInvaderType(grid[y][x].type)) c++;
    }
  }
  return c;
}
function isEngaged(u){ return countAdjacentInvaders(u.x, u.y) > 0; }

function tryMove(u, dx, dy){
  const tx = u.x + dx;
  const ty = u.y + dy;
  if(!inBounds(tx,ty)) return;

  if(u.type==='yours' && isEngaged(u)){
    if(PRESSURE.blockDiagonalWhenEngaged && dx!==0 && dy!==0) return;
    if(Math.random() < PRESSURE.shoveChance) return;
  }

  if(grid[ty][tx]) return;

  grid[u.y][u.x] = null;
  u.x = tx; u.y = ty;
  grid[ty][tx] = u;
}

// =========================
//  COMBAT
// =========================
function attack(atk, def){
  let dmg = (atk.type === 'cavalry') ? 2 : 1;

  def.hp -= dmg;
  spawnBlood(def.x, def.y);
  spawnFloat("-"+dmg, def.x, def.y, "#ef4444");

  if(isInvaderType(atk.type) && !isInvaderType(def.type) && def.hp>0){
    if(Math.random() < PRESSURE.shoveChance){
      let dx = def.x - atk.x;
      let dy = def.y - atk.y;
      let tx = def.x + dx;
      let ty = def.y + dy;

      if(inBounds(tx,ty)){
        if(!grid[ty][tx]){
          grid[def.y][def.x] = null;
          def.x = tx; def.y = ty;
          grid[ty][tx] = def;
          spawnFloat("SHOVE", def.x, def.y, "#fff");
        } else {
          def.hp -= 2;
          spawnFloat("CRUSH", def.x, def.y, "#f00");
        }
      }
    }
  }

  if(def.hp<=0){
    grid[def.y][def.x]=null;
    spawnFloat("KILL", def.x, def.y, P.gold);
  }
}

// Player attack (keyboard + mobile)
function handlePlayerAttack(){
  if(!gameActive || !player || player.hp<=0) return;
  if(atkCD>0) return;
  atkCD = PLAYER_ATTACK.cooldownFrames;

  const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  let hits = 0;
  for(const d of dirs){
    if(hits >= PLAYER_ATTACK.maxHits) break;
    const tx = player.x + d[0];
    const ty = player.y + d[1];
    const t = grid[ty]?.[tx];
    if(t && isInvaderType(t.type)){
      attack(player, t);
      hits++;
    }
  }
  spawnFloat(hits===0 ? "SWING" : "SLASH", player.x, player.y, "#fff");
}

// =========================
//  INPUT: KEYBOARD + TOUCH
// =========================
window.addEventListener('keydown', e => {
  const code = e.code;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD','Space'].includes(code)){
    e.preventDefault();
  }
  if(code==='KeyW' || code==='ArrowUp') keys.up=true;
  if(code==='KeyA' || code==='ArrowLeft') keys.left=true;
  if(code==='KeyS' || code==='ArrowDown') keys.down=true;
  if(code==='KeyD' || code==='ArrowRight') keys.right=true;
  if(code==='Space') handlePlayerAttack();
}, {passive:false});

window.addEventListener('keyup', e => {
  const code = e.code;
  if(code==='KeyW' || code==='ArrowUp') keys.up=false;
  if(code==='KeyA' || code==='ArrowLeft') keys.left=false;
  if(code==='KeyS' || code==='ArrowDown') keys.down=false;
  if(code==='KeyD' || code==='ArrowRight') keys.right=false;
}, {passive:true});

// Mobile: drag anywhere on battlefield to set direction; double tap to attack
STAGE.addEventListener('pointerdown', (e)=>{
  if(!gameActive) return;
  const now = Date.now();
  if(now - touchMove.lastTap < 280){
    handlePlayerAttack();
  }
  touchMove.lastTap = now;

  touchMove.active = true;
  touchMove.startX = e.clientX;
  touchMove.startY = e.clientY;
  touchMove.dx = 0;
  touchMove.dy = 0;
  STAGE.setPointerCapture(e.pointerId);
}, {passive:false});

STAGE.addEventListener('pointermove', (e)=>{
  if(!touchMove.active || !gameActive) return;
  e.preventDefault();
  const dx = e.clientX - touchMove.startX;
  const dy = e.clientY - touchMove.startY;

  // choose cardinal direction
  touchMove.dx = 0; touchMove.dy = 0;
  if(Math.abs(dx) > 18 || Math.abs(dy) > 18){
    if(Math.abs(dx) > Math.abs(dy)) touchMove.dx = Math.sign(dx);
    else touchMove.dy = Math.sign(dy);
  }
}, {passive:false});

function endTouch(){
  touchMove.active = false;
  touchMove.dx = 0;
  touchMove.dy = 0;
}
STAGE.addEventListener('pointerup', endTouch, {passive:true});
STAGE.addEventListener('pointercancel', endTouch, {passive:true});
STAGE.addEventListener('lostpointercapture', endTouch, {passive:true});

// =========================
//  VISUALS
// =========================
function draw(){
  CTX.fillStyle='#2d332d';
  CTX.fillRect(0,0,VIEW_W,VIEW_H);

  CTX.save();
  const cx = VIEW_W/2 - cam.x*SCALE;
  const cy = VIEW_H/2 - cam.y*SCALE;
  CTX.translate(Math.round(cx), Math.round(cy));
  CTX.scale(SCALE, SCALE);

  // Ground Grid
  CTX.strokeStyle='rgba(255,255,255,0.03)';
  CTX.lineWidth=1;
  CTX.beginPath();
  for(let i=0; i<GRID_W; i++){ CTX.moveTo(i*TILE,0); CTX.lineTo(i*TILE,GRID_H*TILE); }
  for(let i=0; i<GRID_H; i++){ CTX.moveTo(0,i*TILE); CTX.lineTo(GRID_W*TILE,i*TILE); }
  CTX.stroke();

  let all = [...units, player];
  all.sort((a,b)=>a.y - b.y);

  for(let u of all){
    if(!u || u.hp<=0) continue;
    drawSprite(u.type, u.x*TILE-4, u.y*TILE-8);

    if(u.type==='yours' || u.hp < u.maxHp){
      const sx=u.x*TILE-4, sy=u.y*TILE-8;
      CTX.fillStyle='#000'; CTX.fillRect(sx, sy-6, 24, 4);
      CTX.fillStyle = (u.type==='yours')?'#22c55e':(isInvaderType(u.type)?'#60a5fa':'#ef4444');
      CTX.fillRect(sx+1, sy-5, Math.max(0, (u.hp/u.maxHp)*22), 2);
    }
  }

  for(let p of particles){
    CTX.fillStyle=p.color; CTX.fillRect(p.x, p.y, 1, 1);
  }

  CTX.font="bold 8px monospace"; CTX.textAlign="center";
  for(let f of floats){
    CTX.fillStyle=f.color; CTX.globalAlpha=f.life;
    CTX.fillText(f.text, f.x+TILE/2, f.y);
  }
  CTX.globalAlpha=1;
  CTX.restore();
}

function drawSprite(kind, x, y){
  const coat = kind==='roman' ? P.roman : kind==='yours' ? P.you : P.inv;

  CTX.fillStyle=P.shadow;
  CTX.beginPath(); CTX.ellipse(x+4, y+7, 4, 2, 0,0,Math.PI*2); CTX.fill();

  px(x+1, y+6, 1, P.black); px(x+6, y+6, 1, P.black);
  px(x+2, y+5, 1, P.metal); px(x+5, y+5, 1, P.metal);
  for(let dx=2; dx<=5; dx++) px(x+dx, y+3, 1, coat);

  if(kind==='cavalry'){
    CTX.fillStyle = P.mane;
    CTX.fillRect(x+2, y+2, 4, 4);
  }
}
function px(x,y,s,c){CTX.fillStyle=c; CTX.fillRect(x,y,s,s);}

// =========================
//  UTILS & UI
// =========================
function inBounds(x,y){return x>=0&&x<GRID_W&&y>=0&&y<GRID_H;}
function dist(a,b){return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2);}
function getStep(u,t){
  const dx=t.x-u.x, dy=t.y-u.y;
  if(Math.abs(dx)>Math.abs(dy)) return {x:Math.sign(dx), y:0};
  return {x:0, y:Math.sign(dy)};
}

function spawnBlood(gx, gy){
  for(let i=0;i<3;i++) particles.push({
    x:gx*TILE+12, y:gy*TILE+12, vx:(Math.random()-.5)*2, vy:(Math.random()-.5)*2, life:1, color:'#7f1d1d'
  });
}
function spawnFloat(txt,gx,gy,col){ floats.push({x:gx*TILE, y:gy*TILE, text:txt, life:1, color:col}); }

function updateFX(){
  particles.forEach(p=>{p.x+=p.vx; p.y+=p.vy; p.life-=0.05});
  particles=particles.filter(p=>p.life>0);
  floats.forEach(f=>{f.y-=0.2; f.life-=0.02});
  floats=floats.filter(f=>f.life>0);
}

function showMsg(txt, col){
  const el=document.getElementById('battle-text');
  el.innerText=txt; el.style.color=col; el.style.opacity=1;
  setTimeout(()=>el.style.opacity=0, 3000);
}

function log(msg, type='neutral'){
  const box = document.getElementById('log-box');
  const d = document.createElement('div');
  d.className=`log-line ${type}`;
  d.innerText = msg;
  box.insertBefore(d, box.firstChild);
}

function updateUI(){
  document.getElementById('ui-rome').innerText = units.filter(u=>!isInvaderType(u.type)).length;
  document.getElementById('ui-han').innerText = units.filter(u=>isInvaderType(u.type)).length;
}

// BOOT
resize();
renderIntro();
</script>

</body>
</html>
